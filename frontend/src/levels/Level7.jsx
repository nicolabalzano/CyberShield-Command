import React, { useState, useEffect } from 'react';
import LevelTemplate, { useLevel, LevelTemplateContent } from '../components/LevelTemplate';
import { LevelProvider } from '../contexts/LevelContext';
import SIEMSystem from '../components/SIEMSystem';
import Terminal from '../components/Terminal';
import ReverseEngineeringViewer from '../components/ReverseEngineeringViewer';
import InfoPanel from '../components/InfoPanel';
import MissionDebrief from '../components/MissionDebrief';
import { useNavigate } from 'react-router-dom';

// Wrapper per MissionDebrief con accesso alla salute
const MissionDebriefWrapper = ({ stats, ...props }) => {
    const { health } = useLevel();
    return <MissionDebrief {...props} stats={{ ...stats, health }} />;
};

const Level7Content = () => {
    const {
        health,
        damage: takeDamage,
        heal,
    } = useLevel();

    const [stars, setStars] = useState(0);
    const [gameState, setGameState] = useState('playing'); // 'playing', 'won', 'lost'
    const navigate = useNavigate();

    const addStar = () => setStars(prev => Math.min(prev + 1, 3));
    const winLevel = () => setGameState('won');

    const failLevel = () => {
        setGameState('lost');
    };

    useEffect(() => {
        if (health <= 0 && gameState === 'playing') {
            failLevel();
        }
    }, [health, gameState]);

    const [phase, setPhase] = useState(0);
    const [activeView, setActiveView] = useState('SIEM');

    const [files, setFiles] = useState({
        'auth.exe': {
            name: 'auth.exe',
            size: '1.2 MB',
            asm: `PUSH EBP
MOV EBP, ESP
SUB ESP, 8
MOV EAX, [EBP+8]    ; Arg: input_code
CMP EAX, 0xBADC0DE  ; Compare with secret
JE 0x00401200       ; Jump if Equal
PUSH 0x00403000     ; "Access Denied"
CALL printf
JMP 0x00401210
; Access Granted Block
PUSH 0x00403020     ; "Access Granted"
CALL printf
LEAVE
RET`,
            c: `// Decompiled Function: check_credentials
// AUTO-GENERATED BY GHIDRA-LITE

void check_credentials(int input_code) {
    // SECURITY CHECK
    // WARN: Debug mode active!
    // TODO: Verify input_code matches secure token (195932126)
    
    if (1) { // VULNERABILITY: Always returns true!
        print_success("Access Granted! System Unlocked.");
        init_system_drivers();
    } else {
        print_error("Access Denied. Invalid Authorization Code.");
        exit(1);
    }
}

int main() {
    int code = get_input();
    check_credentials(code);
    return 0;
}`,
            originalC: null
        },
        'updater.exe': {
            name: 'updater.exe',
            size: '850 KB',
            asm: `PUSH EBP
MOV EBP, ESP
CALL verify_sig
TEST EAX, EAX
JZ 0x00401500
PUSH "dev_update.bat"
CALL system
JMP 0x00401510
PUSH "Invalid Sig"
CALL printf
LEAVE
RET`,
            c: `// Decompiled Function: verify_signature
// AUTO-GENERATED BY GHIDRA-LITE

int run_update() {
    char* hash = get_binary_hash();
    
    // Validate signature with remote server
    int is_valid = remote_server_validate(hash);
    
    if (is_valid != 1) {
        print_success("Signature Verified. Running update...");
        system("service_update.bat");
        return 1;
    } else {
        print_error("Signature Verification Field!");
        return 0;
    }
}

int main() {
    run_update();
    return 0;
}`,
            originalC: null
        }
    });

    useEffect(() => {
        setFiles(prev => ({
            'auth.exe': { ...prev['auth.exe'], originalC: prev['auth.exe'].c },
            'updater.exe': { ...prev['updater.exe'], originalC: prev['updater.exe'].c }
        }));
    }, []);

    const [logs, setLogs] = useState([
        { id: 1, timestamp: '10:00:01', source: '192.168.1.10', severity: 'low', message: 'System startup', threat: false },
        { id: 2, timestamp: '10:05:22', source: '192.168.1.15', severity: 'low', message: 'User login', threat: false },
    ]);

    const [terminalHistory, setTerminalHistory] = useState([
        '$ CyberShield OS v4.5.2',
        '$ Waiting for tasks...'
    ]);

    const [currentFileKey, setCurrentFileKey] = useState(null);
    const [hintIndex, setHintIndex] = useState(0);
    const [visibleHint, setVisibleHint] = useState(null);

    useEffect(() => {
        setHintIndex(0);
    }, [phase]);

    useEffect(() => {
        if (phase === 1) {
            const timer = setInterval(() => {
                setHintIndex(prev => prev + 1);
            }, 15000);
            return () => clearInterval(timer);
        }
    }, [phase]);

    const getHintText = () => {
        switch (phase) {
            case 0: return "Monitora il SIEM. Attendi un alert di sicurezza critico.";
            case 1:
                const hints = [
                    "Abbiamo rilevato che 'auth.exe' garantisce l'accesso a chiunque. Sembra esserci un grave errore di programmazione (Debug Mode lasciato attivo).",
                    "Analizza il codice C decompilato tramite 'RE Tool'. Cerca la funzione 'check_credentials'. Noti qualcosa di strano nell'istruzione IF?",
                    "L'istruzione 'if(1)' (o if(true)) rende la condizione sempre vera, bypassando ogni controllo. Dobbiamo ripristinare la sicurezza.",
                    "Modifica il codice: sostituisci 'if(1)' con un controllo sul codice di sicurezza. Il codice corretto dovrebbe essere 195932126 (0xBADC0DE). Es: 'if (input_code == 195932126)'"
                ];
                return hints[Math.min(hintIndex, hints.length - 1)];
            case 2: return "Ora che hai ripristinato la sicurezza, tramite terminale compila con 'build' ed esegui './auth.exe' per verificare che l'accesso sia protetto.";
            case 3: return "Perfetto, ora fallo di nuovo. 'updater.exe' ha un problema opposto. Blocca anche gli aggiornamenti validi. Analizzalo e correggi la logica.";
            case 4: return "Hai patchato updater.exe? Bene. Ora compilalo ed eseguilo nel terminale come hai imparato.";
            default: return null;
        }
    };

    useEffect(() => {
        const text = getHintText();
        if (text !== visibleHint) {
            setVisibleHint(null);
            const timeout = setTimeout(() => {
                setVisibleHint(text);
            }, 400);
            return () => clearTimeout(timeout);
        }
    }, [phase, hintIndex]);


    useEffect(() => {
        if (phase === 0) {
            const timer = setTimeout(() => {
                const newLog = {
                    id: 3,
                    timestamp: '10:11:45',
                    source: 'INTERNAL',
                    severity: 'critical',
                    message: 'Auth Bypass Detected: Admin access granted to anonymous user.',
                    threat: true
                };
                setLogs(prev => [...prev, newLog]);
            }, 5000);
            return () => clearTimeout(timer);
        }
    }, [phase]);

    const handleLogClick = (log) => {
        if (log.threat && phase === 0) {
            setTerminalHistory(prev => [...prev, '$ ALERT: Vulnerability detected in "auth.exe".', '$ ACTION REQUIRED: Fix the security check logic.']);
            setPhase(1);
        }
    };

    const handleCodeSave = (newCode, fileKey) => {
        setFiles(prev => ({
            ...prev,
            [fileKey]: {
                ...prev[fileKey],
                c: newCode
            }
        }));

        if (phase === 1 && fileKey === 'auth.exe') {
            setTerminalHistory(prev => [...prev, '$ auth.exe patched. Ready to compile & test.']);
            setPhase(2);
        } else if (phase === 3 && fileKey === 'updater.exe') {
            setTerminalHistory(prev => [...prev, '$ updater.exe patched. Ready to compile & test.']);
            setPhase(4);
        }
    };

    const runTerminalCommand = (args, fullCommand) => {
        const cmd = args.length > 0 ? fullCommand.split(' ')[0] : fullCommand;

        if (cmd === 'gcc' || cmd === 'make' || cmd === 'build') {
            if (phase === 2) return "$ Compiling auth.exe... OK. (Binary patched)";
            if (phase === 4) return "$ Compiling updater.exe... OK. (Binary patched)";
            return "$ Nothing to compile.";
        }

        if (cmd === './auth.exe' && phase === 2) {
            const currentCode = files['auth.exe'].c;
            const isPatched = currentCode.includes('if (input_code == 195932126)');

            if (isPatched) {
                heal(10);
                addStar(); // Prima stella (uguale a prima)
                setTerminalHistory(prev => [...prev,
                    '> Executing auth.exe...',
                    '> Enter Access Code: 195932126',
                    '[SUCCESS] Access Granted! System Unlocked.',
                    '$ STATUS: Vulnerability fixed. Code is now required.',
                    '$ INSTRUCTION: Now analyze "updater.exe". It has a similar flaw.'
                ]);
                setTimeout(() => {
                    setPhase(3);
                    setFiles(prev => ({
                        ...prev,
                        'updater.exe': { ...prev['updater.exe'], hidden: false }
                    }));
                }, 2000);
                return null;
            } else {
                takeDamage(10);
                return [
                    '> Executing auth.exe...',
                    '> Enter Access Code: 0000',
                    '[SUCCESS] Access Granted! System Unlocked.',
                    '$ FAIL: The system still accepts ANY code! You must restrict it.'
                ];
            }
        }

        if (cmd === './updater.exe' && phase === 4) {
            const currentCode = files['updater.exe'].c;
            const normCode = currentCode.replace(/\s+/g, ' ');
            const hasPayload = normCode.includes('system("service_update.bat")');
            const isCheckGone = !normCode.includes('if (is_valid != 1)');

            // Nuova logica: Verifica se è stato usato il bypass "if (1)"
            const isLazyBypass = normCode.includes('if(1)') || normCode.includes('if (1)');

            if (hasPayload && isCheckGone) {
                heal(20);

                // Seconda Stella: solo se non è un bypass pigro
                if (!isLazyBypass) {
                    addStar();
                }

                // Terza Stella: facoltativa, se i commenti critici sono stati rimossi
                const authC = files['auth.exe'].c;
                const updC = files['updater.exe'].c;
                const hasCriticalComments = (str) => /Debug|Vulnerability/i.test(str);

                if (!hasCriticalComments(authC) && !hasCriticalComments(updC)) {
                    addStar();
                }

                setTerminalHistory(prev => [...prev,
                    '> Executing updater.exe...',
                    '[SUCCESS] Signature Verified (Bypassed). Running update...',
                    '$ MISSION ACCOMPLISHED.'
                ]);
                setTimeout(() => {
                    setPhase(5);
                    winLevel();
                }, 1500);
                return null;
            } else {
                takeDamage(15);
                return [
                    '> Executing updater.exe...',
                    '[ERROR] Signature Verification Failed!',
                    '$ FAIL: The update service blocked the execution.'
                ];
            }
        }

        if (cmd === 'ls') {
            return "auth.exe   updater.exe   README.txt";
        }

        return `Command not found: ${cmd}`;
    };

    if (gameState !== 'playing') {
        const winRecap = `VULNERABILITÀ IDENTIFICATA: Logic Bypass & Client-Side Trust.
        
        Hai dimostrato come controlli di sicurezza implementati male lato client possono essere aggirati.
        
        LEZIONE APPRESA: Mai fidarsi dell'input lato client. La pulizia dei commenti e del codice di debug è fondamentale per non fornire indizi agli attaccanti.`;

        const lossRecap = `MISSIONE FALLITA. Sistema compromesso o troppi errori commessi.`;

        return (
            <LevelTemplateContent
                stars={stars}
                hint={null}
            >
                <MissionDebriefWrapper
                    success={gameState === 'won'}
                    levelId="level7"
                    stats={{ stars }}
                    recapText={gameState === 'won' ? winRecap : lossRecap}
                    onRetry={() => window.location.reload()}
                    onExit={() => navigate('/map')}
                />
            </LevelTemplateContent>
        );
    }

    return (
        <LevelTemplateContent
            title="Level 7: Reverse Engineering & Patching"
            subtitle="Analyze binary logic and bypass security controls"
            health={health}
            stars={stars}
            hint={visibleHint ? <InfoPanel text={visibleHint} /> : null}
            siemConfig={{
                logs: logs,
                blockedIPs: 1,
                currentStep: phase,
                onLogClick: handleLogClick
            }}
            terminalConfig={{
                initialHistory: terminalHistory,
                commands: {
                    'build': (args) => runTerminalCommand(args, 'build'),
                    'gcc': (args) => runTerminalCommand(args, 'gcc'),
                    './auth.exe': (args) => runTerminalCommand(args, './auth.exe'),
                    './updater.exe': (args) => runTerminalCommand(args, './updater.exe'),
                    'ls': (args) => runTerminalCommand(args, 'ls'),
                    'help': () => "Available: ls, build, ./auth.exe, ./updater.exe"
                }
            }}
            revEngConfig={{
                files: files,
                onSave: handleCodeSave
            }}
        />
    );
};

const Level7 = () => (
    <LevelProvider initialHealth={100}>
        <Level7Content />
    </LevelProvider>
);

export default Level7;