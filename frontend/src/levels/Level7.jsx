import React, { useState, useEffect } from 'react';
import LevelTemplate, { useLevel, LevelTemplateContent } from '../components/LevelTemplate';
import { LevelProvider } from '../contexts/LevelContext';
import SIEMSystem from '../components/SIEMSystem';
import Terminal from '../components/Terminal';
import ReverseEngineeringViewer from '../components/ReverseEngineeringViewer';
import InfoPanel from '../components/InfoPanel';
import LevelCompleted from '../components/LevelCompleted';

const Level7Content = () => {
    const {
        health,
        takeDamage,
        heal,
        stars,
        addStar,
        isLevelCompleted,
        completeLevel,
        failLevel
    } = useLevel(7, 100);

    // Game Phase: 
    // 0: SIEM Monitoring (Waiting for alert)
    // 1: Analysis of auth.exe (RevEng)
    // 2: Building/Running auth.exe (Terminal)
    // 3: Analysis of updater.exe (RevEng - Challenge)
    // 4: Building/Running updater.exe (Terminal)
    // 5: Finished
    const [phase, setPhase] = useState(0);
    const [activeView, setActiveView] = useState('SIEM'); // SIEM, REV, TERMINAL
    
    // Virtual Files
    const [files, setFiles] = useState({
        'auth.exe': {
            name: 'auth.exe',
            size: '1.2 MB',
            asm: `PUSH EBP
MOV EBP, ESP
SUB ESP, 8
MOV EAX, [EBP+8]    ; Arg: input_code
CMP EAX, 0xBADC0DE  ; Compare with secret
JE 0x00401200       ; Jump if Equal
PUSH 0x00403000     ; "Access Denied"
CALL printf
JMP 0x00401210
; Access Granted Block
PUSH 0x00403020     ; "Access Granted"
CALL printf
LEAVE
RET`,
            c: `// Decompiled Function: check_credentials
// AUTO-GENERATED BY GHIDRA-LITE

void check_credentials(int input_code) {
    // SECURITY CHECK
    // WARN: Debug mode active!
    // TODO: Verify input_code matches secure token (195932126)
    
    if (1) { // VULNERABILITY: Always returns true!
        print_success("Access Granted! System Unlocked.");
        init_system_drivers();
    } else {
        print_error("Access Denied. Invalid Authorization Code.");
        exit(1);
    }
}

int main() {
    int code = get_input();
    check_credentials(code);
    return 0;
}`,
            originalC: null // Populated in useEffect
        },
        'updater.exe': {
            name: 'updater.exe',
            size: '850 KB',
            asm: `PUSH EBP
MOV EBP, ESP
CALL verify_sig
TEST EAX, EAX
JZ 0x00401500
PUSH "dev_update.bat"
CALL system
JMP 0x00401510
PUSH "Invalid Sig"
CALL printf
LEAVE
RET`,
            c: `// Decompiled Function: verify_signature
// AUTO-GENERATED BY GHIDRA-LITE

int run_update() {
    char* hash = get_binary_hash();
    
    // Validate signature with remote server
    int is_valid = remote_server_validate(hash);
    
    if (is_valid == 1) {
        print_success("Signature Verified. Running update...");
        system("service_update.bat");
        return 1;
    } else {
        print_error("Signature Verification Field!");
        return 0;
    }
}

int main() {
    run_update();
    return 0;
}`,
            originalC: null
        }
    });

    // Store original C code for comparison
    useEffect(() => {
        setFiles(prev => ({
            'auth.exe': { ...prev['auth.exe'], originalC: prev['auth.exe'].c },
            'updater.exe': { ...prev['updater.exe'], originalC: prev['updater.exe'].c }
        }));
    }, []);

    // SIEM Logs
    const [logs, setLogs] = useState([
        { id: 1, timestamp: '10:00:01', source: '192.168.1.10', severity: 'low', message: 'System startup', threat: false },
        { id: 2, timestamp: '10:05:22', source: '192.168.1.15', severity: 'low', message: 'User login', threat: false },
    ]);

    // Terminal State
    const [terminalHistory, setTerminalHistory] = useState([
        '$ CyberShield OS v4.5.2',
        '$ Waiting for tasks...'
    ]);

    // Current File being edited
    const [currentFileKey, setCurrentFileKey] = useState(null);
    const [hintIndex, setHintIndex] = useState(0);

    // Reset hint index when phase changes
    useEffect(() => {
        setHintIndex(0);
    }, [phase]);

    // Timer for progressive hints in Phase 1
    useEffect(() => {
        if (phase === 1) {
            const timer = setInterval(() => {
                setHintIndex(prev => prev + 1);
            }, 10000); // 10 seconds per hint
            return () => clearInterval(timer);
        }
    }, [phase]);

    const getHintText = () => {
        switch(phase) {
            case 0: return "Monitora il SIEM. Attendi un alert di sicurezza critico.";
            case 1: 
                const hints = [
                    "Abbiamo rilevato che 'auth.exe' garantisce l'accesso a chiunque. Sembra esserci un grave errore di programmazione (Debug Mode lasciato attivo).",
                    "Analizza il codice C decompilato. Cerca la funzione 'check_credentials'. Noti qualcosa di strano nell'istruzione IF?",
                    "L'istruzione 'if(1)' (o if(true)) rende la condizione sempre vera, bypassando ogni controllo. Dobbiamo ripristinare la sicurezza.",
                    "Modifica il codice: sostituisci 'if(1)' con un controllo sul codice di sicurezza. Il codice corretto dovrebbe essere 195932126 (0xBADC0DE). Es: 'if (input_code == 195932126)'"
                ];
                return hints[Math.min(hintIndex, hints.length - 1)];
            case 2: return "Ora che hai ripristinato la sicurezza, compila ed esegui './auth.exe' per verificare che l'accesso sia protetto.";
            case 3: return "Sfida: 'updater.exe' ha un problema opposto. Blocca anche gli aggiornamenti validi. Analizzalo e correggi la logica.";
            case 4: return "Hai patchato updater.exe? Bene. Ora compilalo ed eseguilo nel terminale come prima.";
            default: return null;
        }
    };

    const currentHint = getHintText();

    // Trigger SIEM Alert after a delay
    useEffect(() => {
        if (phase === 0) {
            const timer = setTimeout(() => {
                const newLog = { 
                    id: 3, 
                    timestamp: '10:11:45', 
                    source: 'INTERNAL', 
                    severity: 'critical', 
                    message: 'Auth Bypass Detected: Admin access granted to anonymous user.', 
                    threat: true 
                };
                setLogs(prev => [...prev, newLog]);
            }, 5000);
            return () => clearTimeout(timer);
        }
    }, [phase]);

    const handleLogClick = (log) => {
        if (log.threat && phase === 0) {
            setTerminalHistory(prev => [...prev, '$ ALERT: Vulnerability detected in "auth.exe".', '$ ACTION REQUIRED: Fix the security check logic.']);
            setPhase(1);
            // Auto switch to Rev view hint
            setTimeout(() => {
                // Hint/Alert handled visually or via InfoPanel normally, avoiding windows alert if possible
            }, 500);
        }
    };

    const handleCodeSave = (newCode, fileKey) => {
        // Update file in simulated filesystem
        setFiles(prev => ({
            ...prev,
            [fileKey]: {
                ...prev[fileKey],
                c: newCode
            }
        }));

        if (phase === 1 && fileKey === 'auth.exe') {
            setTerminalHistory(prev => [...prev, '$ auth.exe patched. Ready to compile & test.']);
            setPhase(2);
            // Hint user to use terminal
             alert("File patched! Now open TERMINAL and run 'build' then './auth.exe'");
        } else if (phase === 3 && fileKey === 'updater.exe') {
            setTerminalHistory(prev => [...prev, '$ updater.exe patched. Ready to compile & test.']);
            setPhase(4);
            alert("File patched! Now open TERMINAL and run 'build' then './updater.exe'");
        }
    };

    const runTerminalCommand = (args, fullCommand) => {
        const cmd = args.length > 0 ? fullCommand.split(' ')[0] : fullCommand;
        
        // BUILD COMMAND
        if (cmd === 'gcc' || cmd === 'make' || cmd === 'build') {
            if (phase === 2) {
                return "$ Compiling auth.exe... OK. (Binary patched)";
            }
            if (phase === 4) {
                return "$ Compiling updater.exe... OK. (Binary patched)";
            }
            return "$ Nothing to compile.";
        }

        // EXECUTION COMMAND
        if (cmd === './auth.exe' && phase === 2) {
            const currentCode = files['auth.exe'].c;
            // Check if patched correctly (Secure check IMPLEMENTED)
            const isPatched = currentCode.includes('if (input_code == 195932126)');
            
            if (isPatched) {
                heal(10);
                addStar(); // Star for first part
                setTerminalHistory(prev => [...prev, 
                    '> Executing auth.exe...',
                    '> Enter Access Code: 195932126',
                    '[SUCCESS] Access Granted! System Unlocked.',
                    '$ STATUS: Vulnerability fixed. Code is now required.',
                    '$ EXPLANATION: Great job patching the logic error.',
                    '$ INSTRUCTION: Now analyze "updater.exe". It has a similar flaw.'
                ]);
                setTimeout(() => {
                    setPhase(3);
                    // Enable updater in hidden way? No, simple phase switch.
                    setFiles(prev => ({
                        ...prev,
                        'updater.exe': { ...prev['updater.exe'], hidden: false }
                    }));
                    alert("Auth fixed! Now analyze 'updater.exe'.");
                }, 2000);
                return null;
            } else {
                takeDamage(10);
                return [
                    '> Executing auth.exe...',
                    '> Enter Access Code: 0000',
                    '[SUCCESS] Access Granted! System Unlocked.',
                    '$ FAIL: The system still accepts ANY code! You must restrict it.'
                ];
            }
        }

        if (cmd === './updater.exe' && phase === 4) {
            const currentCode = files['updater.exe'].c;
            // Check patch
            const isPatched = (!currentCode.includes('if (is_valid == 1)') && currentCode.includes('system("service_update.bat")')) ||
                              (currentCode.includes('if (1)') && currentCode.includes('system("service_update.bat")'));

            if (isPatched) {
                heal(20);
                addStar(); // Star for second part
                setTerminalHistory(prev => [...prev, 
                    '> Executing updater.exe...',
                    '[SUCCESS] Signature Verified (Bypassed). Running update...',
                    '$ MISSION ACCOMPLISHED.'
                ]);
                setTimeout(() => {
                    setPhase(5);
                    completeLevel();
                }, 1500);
                return null;
            } else {
                takeDamage(15);
                return [
                    '> Executing updater.exe...',
                    '[ERROR] Signature Verification Failed!',
                    '$ FAIL: The update service blocked the execution.'
                ];
            }
        }

        // UTILS
        if (cmd === 'ls') {
            return "auth.exe   updater.exe   README.txt";
        }
        
        return `Command not found: ${cmd}`;
    };

    // --- RENDER ---

    if (isLevelCompleted) {
        return <LevelCompleted stats={{ health, stars }} level={7} />;
    }

    return (
        <LevelTemplateContent 
            title="Level 7: Reverse Engineering & Patching"
            subtitle="Analyze binary logic and bypass security controls"
            health={health}
            stars={stars}
            hint={currentHint ? <InfoPanel text={currentHint} /> : null}
            siemConfig={{
                logs: logs,
                blockedIPs: 1,
                currentStep: phase,
                onLogClick: handleLogClick
            }}
            terminalConfig={{
                initialHistory: terminalHistory,
                commands: {
                    'build': (args) => runTerminalCommand(args, 'build'),
                    'gcc': (args) => runTerminalCommand(args, 'gcc'),
                    './auth.exe': (args) => runTerminalCommand(args, './auth.exe'), 
                    './updater.exe': (args) => runTerminalCommand(args, './updater.exe'),
                    'ls': (args) => runTerminalCommand(args, 'ls'),
                    'help': () => "Available: ls, build, ./auth.exe, ./updater.exe"
                }
            }}
            revEngConfig={{
                files: files,
                onSave: handleCodeSave
            }}
        />
    );
};

const Level7 = () => (
    <LevelProvider initialHealth={100}>
        <Level7Content />
    </LevelProvider>
);

export default Level7;
