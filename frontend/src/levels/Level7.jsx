import React, { useState, useEffect } from 'react';
import LevelTemplate, { useLevel, LevelTemplateContent } from '../components/LevelTemplate';
import { LevelProvider } from '../contexts/LevelContext';
import { useLanguage } from '../contexts/LanguageContext';
import { translations } from '../translations';
import SIEMSystem from '../components/SIEMSystem';
import Terminal from '../components/Terminal';
import ReverseEngineeringViewer from '../components/ReverseEngineeringViewer';
import InfoPanel from '../components/InfoPanel';
import MissionDebrief from '../components/MissionDebrief';
import { useNavigate } from 'react-router-dom';

// Wrapper per MissionDebrief con accesso alla salute
const MissionDebriefWrapper = ({ stats, ...props }) => {
    const { health } = useLevel();
    return <MissionDebrief {...props} stats={{ ...stats, health }} />;
};

const Level7Content = () => {
    const { language } = useLanguage();
    const t = translations[language]?.level7 || translations['italiano'].level7;

    const {
        health,
        damage: takeDamage,
        heal,
    } = useLevel();

    const [stars, setStars] = useState(0);
    const [gameState, setGameState] = useState('playing'); // 'playing', 'won', 'lost'
    const navigate = useNavigate();

    const addStar = () => setStars(prev => Math.min(prev + 1, 3));
    const winLevel = () => setGameState('won');

    const failLevel = () => {
        setGameState('lost');
    };

    useEffect(() => {
        if (health <= 0 && gameState === 'playing') {
            failLevel();
        }
    }, [health, gameState]);

    const [phase, setPhase] = useState(0);
    const [activeView, setActiveView] = useState('SIEM');

    const [files, setFiles] = useState({
        'auth.exe': {
            name: 'auth.exe',
            size: '1.2 MB',
            asm: `PUSH EBP
MOV EBP, ESP
SUB ESP, 8
MOV EAX, [EBP+8]    ; Arg: input_code
CMP EAX, 0xBADC0DE  ; Compare with secret
JE 0x00401200       ; Jump if Equal
PUSH 0x00403000     ; "Access Denied"
CALL printf
JMP 0x00401210
; Access Granted Block
PUSH 0x00403020     ; "Access Granted"
CALL printf
LEAVE
RET`,
            c: `// Decompiled Function: check_credentials
// AUTO-GENERATED BY GHIDRA-LITE

void check_credentials(int input_code) {
    // SECURITY CHECK
    // WARN: Debug mode active!
    // TODO: Verify input_code matches secure token (195932126)
    
    if (1) { // VULNERABILITY: Always returns true!
        print_success("Access Granted! System Unlocked.");
        init_system_drivers();
    } else {
        print_error("Access Denied. Invalid Authorization Code.");
        exit(1);
    }
}

int main() {
    int code = get_input();
    check_credentials(code);
    return 0;
}`,
            originalC: null
        },
        'updater.exe': {
            name: 'updater.exe',
            size: '850 KB',
            asm: `PUSH EBP
MOV EBP, ESP
CALL verify_sig
TEST EAX, EAX
JZ 0x00401500
PUSH "dev_update.bat"
CALL system
JMP 0x00401510
PUSH "Invalid Sig"
CALL printf
LEAVE
RET`,
            c: `// Decompiled Function: verify_signature
// AUTO-GENERATED BY GHIDRA-LITE

int run_update() {
    char* hash = get_binary_hash();
    
    // Validate signature with remote server
    int is_valid = remote_server_validate(hash);
    
    if (is_valid != 1) {
        print_success("Signature Verified. Running update...");
        system("service_update.bat");
        return 1;
    } else {
        print_error("Signature Verification Field!");
        return 0;
    }
}

int main() {
    run_update();
    return 0;
}`,
            originalC: null
        }
    });

    useEffect(() => {
        setFiles(prev => ({
            'auth.exe': { ...prev['auth.exe'], originalC: prev['auth.exe'].c },
            'updater.exe': { ...prev['updater.exe'], originalC: prev['updater.exe'].c }
        }));
    }, []);

    const [logs, setLogs] = useState([
        { id: 1, timestamp: '10:00:01', source: '192.168.1.10', severity: 'low', message: 'startup', threat: false },
        { id: 2, timestamp: '10:05:22', source: '192.168.1.15', severity: 'low', message: 'login', threat: false },
    ]);

    const [terminalHistory, setTerminalHistory] = useState([
        '$ CyberShield OS v4.5.2',
        t.terminal.waiting
    ]);

    const [currentFileKey, setCurrentFileKey] = useState(null);
    const [hintIndex, setHintIndex] = useState(0);
    const [visibleHint, setVisibleHint] = useState(null);

    useEffect(() => {
        setHintIndex(0);
    }, [phase]);

    useEffect(() => {
        if (phase === 1) {
            const timer = setInterval(() => {
                setHintIndex(prev => prev + 1);
            }, 15000);
            return () => clearInterval(timer);
        }
    }, [phase]);

    const getHintText = () => {
        switch (phase) {
            case 0: return t.hints.phase0;
            case 1:
                const hints = t.hints.phase1;
                return hints[Math.min(hintIndex, hints.length - 1)];
            case 2: return t.hints.phase2;
            case 3: return t.hints.phase3;
            case 4: return t.hints.phase4;
            default: return null;
        }
    };

    useEffect(() => {
        const text = getHintText();
        if (text !== visibleHint) {
            setVisibleHint(null);
            const timeout = setTimeout(() => {
                setVisibleHint(text);
            }, 400);
            return () => clearTimeout(timeout);
        }
    }, [phase, hintIndex]);


    useEffect(() => {
        if (phase === 0) {
            const timer = setTimeout(() => {
                const newLog = {
                    id: 3,
                    timestamp: '10:11:45',
                    source: 'INTERNAL',
                    severity: 'critical',
                    message: 'bypass',
                    threat: true
                };
                setLogs(prev => [...prev, newLog]);
            }, 5000);
            return () => clearTimeout(timer);
        }
    }, [phase]);

    const handleLogClick = (log) => {
        if (log.threat && phase === 0) {
            setTerminalHistory(prev => [...prev, t.terminal.alert, t.terminal.action]);
            setPhase(1);
        }
    };

    const handleCodeSave = (newCode, fileKey) => {
        setFiles(prev => ({
            ...prev,
            [fileKey]: {
                ...prev[fileKey],
                c: newCode
            }
        }));

        if (phase === 1 && fileKey === 'auth.exe') {
            setTerminalHistory(prev => [...prev, t.terminal.authPatched]);
            setPhase(2);
        } else if (phase === 3 && fileKey === 'updater.exe') {
            setTerminalHistory(prev => [...prev, t.terminal.updaterPatched]);
            setPhase(4);
        }
    };

    const runTerminalCommand = (args, fullCommand) => {
        const cmd = args.length > 0 ? fullCommand.split(' ')[0] : fullCommand;

        if (cmd === 'gcc' || cmd === 'make' || cmd === 'build') {
            if (phase === 2) return t.terminal.compilingAuth;
            if (phase === 4) return t.terminal.compilingUpdater;
            return t.terminal.nothing;
        }

        if (cmd === './auth.exe' && phase === 2) {
            const currentCode = files['auth.exe'].c;
            const isPatched = currentCode.includes('if (input_code == 195932126)');

            if (isPatched) {
                heal(10);
                addStar(); // Prima stella (uguale a prima)
                setTerminalHistory(prev => [...prev,
                t.terminal.execAuth,
                t.terminal.enterCode,
                t.terminal.accessGranted,
                t.terminal.vulnFixed,
                t.terminal.nextInstruction
                ]);
                setTimeout(() => {
                    setPhase(3);
                    setFiles(prev => ({
                        ...prev,
                        'updater.exe': { ...prev['updater.exe'], hidden: false }
                    }));
                }, 2000);
                return null;
            } else {
                takeDamage(10);
                return [
                    t.terminal.execAuth,
                    '> Enter Access Code: 0000',
                    t.terminal.accessGranted,
                    t.terminal.failAuth
                ];
            }
        }

        if (cmd === './updater.exe' && phase === 4) {
            const currentCode = files['updater.exe'].c;
            const normCode = currentCode.replace(/\s+/g, ' ');
            const hasPayload = normCode.includes('system("service_update.bat")');
            const isCheckGone = !normCode.includes('if (is_valid != 1)');

            // Nuova logica: Verifica se è stato usato il bypass "if (1)"
            const isLazyBypass = normCode.includes('if(1)') || normCode.includes('if (1)');

            if (hasPayload && isCheckGone) {
                heal(20);

                // Seconda Stella: solo se non è un bypass pigro
                if (!isLazyBypass) {
                    addStar();
                }

                // Terza Stella: facoltativa, se i commenti critici sono stati rimossi
                const authC = files['auth.exe'].c;
                const updC = files['updater.exe'].c;
                const hasCriticalComments = (str) => /Debug|Vulnerability/i.test(str);

                if (!hasCriticalComments(authC) && !hasCriticalComments(updC)) {
                    addStar();
                }

                setTerminalHistory(prev => [...prev,
                t.terminal.execUpdater,
                t.terminal.sigVerified,
                t.terminal.missionAccomplished
                ]);
                setTimeout(() => {
                    setPhase(5);
                    winLevel();
                }, 1500);
                return null;
            } else {
                takeDamage(15);
                return [
                    t.terminal.execUpdater,
                    t.terminal.sigFailed,
                    t.terminal.failUpdater
                ];
            }
        }

        if (cmd === 'ls') {
            return "auth.exe   updater.exe   README.txt";
        }

        return `Command not found: ${cmd}`;
    };

    if (gameState !== 'playing') {
        const winRecap = `VULNERABILITÀ IDENTIFICATA: Logic Bypass & Client-Side Trust.
        
        Hai dimostrato come controlli di sicurezza implementati male lato client possono essere aggirati.
        
        LEZIONE APPRESA: Mai fidarsi dell'input lato client. La pulizia dei commenti e del codice di debug è fondamentale per non fornire indizi agli attaccanti.`;

        const lossRecap = `MISSIONE FALLITA. Sistema compromesso o troppi errori commessi.`;

        return (
            <LevelTemplateContent
                stars={stars}
                hint={null}
            >
                <MissionDebriefWrapper
                    success={gameState === 'won'}
                    levelId="level7"
                    stats={{ stars }}
                    recapText={gameState === 'won' ? t.debrief.win : t.debrief.loss}
                    onRetry={() => window.location.reload()}
                    onExit={() => navigate('/map')}
                />
            </LevelTemplateContent>
        );
    }

    return (
        <LevelTemplateContent
            title={t.title}
            subtitle={t.subtitle}
            health={health}
            stars={stars}
            hint={visibleHint ? <InfoPanel text={visibleHint} /> : null}
            siemConfig={{
                logs: logs.map(log => ({ ...log, message: t.siem[log.message] || log.message })),
                blockedIPs: 1,
                currentStep: phase,
                onLogClick: handleLogClick
            }}
            terminalConfig={{
                initialHistory: terminalHistory,
                commands: {
                    'build': (args) => runTerminalCommand(args, 'build'),
                    'gcc': (args) => runTerminalCommand(args, 'gcc'),
                    './auth.exe': (args) => runTerminalCommand(args, './auth.exe'),
                    './updater.exe': (args) => runTerminalCommand(args, './updater.exe'),
                    'ls': (args) => runTerminalCommand(args, 'ls'),
                    'help': () => t.terminal.help
                }
            }}
            revEngConfig={{
                files: files,
                onSave: handleCodeSave
            }}
        />
    );
};

const Level7 = () => (
    <LevelProvider initialHealth={100}>
        <Level7Content />
    </LevelProvider>
);

export default Level7;