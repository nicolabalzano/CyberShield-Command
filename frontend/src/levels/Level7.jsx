import React, { useState, useEffect } from 'react';
import LevelTemplate, { useLevel, LevelTemplateContent } from '../components/LevelTemplate';
import { LevelProvider } from '../contexts/LevelContext';
import SIEMSystem from '../components/SIEMSystem';
import Terminal from '../components/Terminal';
import ReverseEngineeringViewer from '../components/ReverseEngineeringViewer';
import InfoPanel from '../components/InfoPanel';
import MissionDebrief from '../components/MissionDebrief';
import { useNavigate } from 'react-router-dom';

const Level7Content = () => {
    // Destructuring only what's available in context (based on check) or mocked locally if missing
    // FIX: LevelContext only provides health commands. Need to handle stars locally or extend context.
    const {
        health,
        damage: takeDamage, // Aliased to match usage
        heal,
        // stars, // Not in provider
        // addStar, // Not in provider
        // completeLevel, // Not in provider
    } = useLevel();
    
    // Local state for missing context features
    const [stars, setStars] = useState(0);
    const [gameState, setGameState] = useState('playing'); // 'playing', 'won', 'lost'
    const navigate = useNavigate();

    const addStar = () => setStars(prev => Math.min(prev + 1, 3));
    const winLevel = () => setGameState('won');
    
    const failLevel = () => {
        setGameState('lost');
    };

    // Check health for loss condition
    useEffect(() => {
        if (health <= 0 && gameState === 'playing') {
            failLevel();
        }
    }, [health, gameState]);


    // Game Phase: 
    // 0: SIEM Monitoring (Waiting for alert)
    // 1: Analysis of auth.exe (RevEng)
    // 2: Building/Running auth.exe (Terminal)
    // 3: Analysis of updater.exe (RevEng - Challenge)
    // 4: Building/Running updater.exe (Terminal)
    // 5: Finished
    const [phase, setPhase] = useState(0);
    const [activeView, setActiveView] = useState('SIEM'); // SIEM, REV, TERMINAL
    
    // Virtual Files
    const [files, setFiles] = useState({
        'auth.exe': {
            name: 'auth.exe',
            size: '1.2 MB',
            asm: `PUSH EBP
MOV EBP, ESP
SUB ESP, 8
MOV EAX, [EBP+8]    ; Arg: input_code
CMP EAX, 0xBADC0DE  ; Compare with secret
JE 0x00401200       ; Jump if Equal
PUSH 0x00403000     ; "Access Denied"
CALL printf
JMP 0x00401210
; Access Granted Block
PUSH 0x00403020     ; "Access Granted"
CALL printf
LEAVE
RET`,
            c: `// Decompiled Function: check_credentials
// AUTO-GENERATED BY GHIDRA-LITE

void check_credentials(int input_code) {
    // SECURITY CHECK
    // WARN: Debug mode active!
    // TODO: Verify input_code matches secure token (195932126)
    
    if (1) { // VULNERABILITY: Always returns true!
        print_success("Access Granted! System Unlocked.");
        init_system_drivers();
    } else {
        print_error("Access Denied. Invalid Authorization Code.");
        exit(1);
    }
}

int main() {
    int code = get_input();
    check_credentials(code);
    return 0;
}`,
            originalC: null // Populated in useEffect
        },
        'updater.exe': {
            name: 'updater.exe',
            size: '850 KB',
            asm: `PUSH EBP
MOV EBP, ESP
CALL verify_sig
TEST EAX, EAX
JZ 0x00401500
PUSH "dev_update.bat"
CALL system
JMP 0x00401510
PUSH "Invalid Sig"
CALL printf
LEAVE
RET`,
            c: `// Decompiled Function: verify_signature
// AUTO-GENERATED BY GHIDRA-LITE

int run_update() {
    char* hash = get_binary_hash();
    
    // Validate signature with remote server
    int is_valid = remote_server_validate(hash);
    
    if (is_valid != 1) {
        print_success("Signature Verified. Running update...");
        system("service_update.bat");
        return 1;
    } else {
        print_error("Signature Verification Field!");
        return 0;
    }
}

int main() {
    run_update();
    return 0;
}`,
            originalC: null
        }
    });

    // Store original C code for comparison
    useEffect(() => {
        setFiles(prev => ({
            'auth.exe': { ...prev['auth.exe'], originalC: prev['auth.exe'].c },
            'updater.exe': { ...prev['updater.exe'], originalC: prev['updater.exe'].c }
        }));
    }, []);

    // SIEM Logs
    const [logs, setLogs] = useState([
        { id: 1, timestamp: '10:00:01', source: '192.168.1.10', severity: 'low', message: 'System startup', threat: false },
        { id: 2, timestamp: '10:05:22', source: '192.168.1.15', severity: 'low', message: 'User login', threat: false },
    ]);

    // Terminal State
    const [terminalHistory, setTerminalHistory] = useState([
        '$ CyberShield OS v4.5.2',
        '$ Waiting for tasks...'
    ]);

    // Current File being edited
    const [currentFileKey, setCurrentFileKey] = useState(null);
    const [hintIndex, setHintIndex] = useState(0);
    const [visibleHint, setVisibleHint] = useState(null);

    // Reset hint index when phase changes
    useEffect(() => {
        setHintIndex(0);
    }, [phase]);

    // Timer for progressive hints in Phase 1
    useEffect(() => {
        if (phase === 1) {
            const timer = setInterval(() => {
                setHintIndex(prev => prev + 1);
            }, 15000); // 15 seconds per hint
            return () => clearInterval(timer);
        }
    }, [phase]);

    // Calculate hint text based on state
    const getHintText = () => {
        switch(phase) {
            case 0: return "Monitora il SIEM. Attendi un alert di sicurezza critico.";
            case 1: 
                const hints = [
                    "Abbiamo rilevato che 'auth.exe' garantisce l'accesso a chiunque. Sembra esserci un grave errore di programmazione (Debug Mode lasciato attivo).",
                    "Analizza il codice C decompilato tramite 'RE Tool'. Cerca la funzione 'check_credentials'. Noti qualcosa di strano nell'istruzione IF?",
                    "L'istruzione 'if(1)' (o if(true)) rende la condizione sempre vera, bypassando ogni controllo. Dobbiamo ripristinare la sicurezza.",
                    "Modifica il codice: sostituisci 'if(1)' con un controllo sul codice di sicurezza. Il codice corretto dovrebbe essere 195932126 (0xBADC0DE). Es: 'if (input_code == 195932126)'"
                ];
                return hints[Math.min(hintIndex, hints.length - 1)];
            case 2: return "Ora che hai ripristinato la sicurezza, tramite terminale compila con 'build' ed esegui './auth.exe' per verificare che l'accesso sia protetto.";
            case 3: return "Perfetto, ora fallo di nuovo. 'updater.exe' ha un problema opposto. Blocca anche gli aggiornamenti validi. Analizzalo e correggi la logica.";
            case 4: return "Hai patchato updater.exe? Bene. Ora compilalo ed eseguilo nel terminale come hai imparato.";
            default: return null;
        }   
    };

    // Effect to flash the hint when it changes
    useEffect(() => {
        const text = getHintText();
        if (text !== visibleHint) {
            setVisibleHint(null); // Hide
            const timeout = setTimeout(() => {
                setVisibleHint(text); // Show new
            }, 400); // Short delay for animation reset
            return () => clearTimeout(timeout);
        }
    }, [phase, hintIndex]); // Re-run when phase or hint index changes


    // Trigger SIEM Alert after a delay
    useEffect(() => {
        if (phase === 0) {
            const timer = setTimeout(() => {
                const newLog = { 
                    id: 3, 
                    timestamp: '10:11:45', 
                    source: 'INTERNAL', 
                    severity: 'critical', 
                    message: 'Auth Bypass Detected: Admin access granted to anonymous user.', 
                    threat: true 
                };
                setLogs(prev => [...prev, newLog]);
            }, 5000);
            return () => clearTimeout(timer);
        }
    }, [phase]);

    const handleLogClick = (log) => {
        if (log.threat && phase === 0) {
            setTerminalHistory(prev => [...prev, '$ ALERT: Vulnerability detected in "auth.exe".', '$ ACTION REQUIRED: Fix the security check logic.']);
            setPhase(1);
            // Auto switch to Rev view hint
            setTimeout(() => {
                // Hint/Alert handled visually or via InfoPanel normally, avoiding windows alert if possible
            }, 500);
        }
    };

    const handleCodeSave = (newCode, fileKey) => {
        // Update file in simulated filesystem
        setFiles(prev => ({
            ...prev,
            [fileKey]: {
                ...prev[fileKey],
                c: newCode
            }
        }));

        if (phase === 1 && fileKey === 'auth.exe') {
            setTerminalHistory(prev => [...prev, '$ auth.exe patched. Ready to compile & test.']);
            setPhase(2);
            // Hint user to use terminal (handled by Hint system on phase change)
        } else if (phase === 3 && fileKey === 'updater.exe') {
            setTerminalHistory(prev => [...prev, '$ updater.exe patched. Ready to compile & test.']);
            setPhase(4);
            // Hint user to use terminal (handled by Hint system on phase change)
        }
    };

    const runTerminalCommand = (args, fullCommand) => {
        const cmd = args.length > 0 ? fullCommand.split(' ')[0] : fullCommand;
        
        // BUILD COMMAND
        if (cmd === 'gcc' || cmd === 'make' || cmd === 'build') {
            if (phase === 2) {
                return "$ Compiling auth.exe... OK. (Binary patched)";
            }
            if (phase === 4) {
                return "$ Compiling updater.exe... OK. (Binary patched)";
            }
            return "$ Nothing to compile.";
        }

        // EXECUTION COMMAND
        if (cmd === './auth.exe' && phase === 2) {
            const currentCode = files['auth.exe'].c;
            // Check if patched correctly (Secure check IMPLEMENTED)
            const isPatched = currentCode.includes('if (input_code == 195932126)');
            
            if (isPatched) {
                heal(10);
                addStar(); // Star for first part
                setTerminalHistory(prev => [...prev, 
                    '> Executing auth.exe...',
                    '> Enter Access Code: 195932126',
                    '[SUCCESS] Access Granted! System Unlocked.',
                    '$ STATUS: Vulnerability fixed. Code is now required.',
                    '$ EXPLANATION: Great job patching the logic error.',
                    '$ INSTRUCTION: Now analyze "updater.exe". It has a similar flaw.'
                ]);
                setTimeout(() => {
                    setPhase(3);
                    // Enable updater in hidden way? No, simple phase switch.
                    setFiles(prev => ({
                        ...prev,
                        'updater.exe': { ...prev['updater.exe'], hidden: false }
                    }));
                    // Alert removed, hint system handles notification
                }, 2000);
                return null;
            } else {
                takeDamage(10);
                return [
                    '> Executing auth.exe...',
                    '> Enter Access Code: 0000',
                    '[SUCCESS] Access Granted! System Unlocked.',
                    '$ FAIL: The system still accepts ANY code! You must restrict it.'
                ];
            }
        }

        if (cmd === './updater.exe' && phase === 4) {
            const currentCode = files['updater.exe'].c;
            
            // Normalize code to ignore extra whitespace
            const normCode = currentCode.replace(/\s+/g, ' ');

            // Check if the payload is still present (we needed to run the update)
            const hasPayload = normCode.includes('system("service_update.bat")');

            // If user writes 'if (is_valid == 1)' it bypass. 
            // If user writes 'if (is_valid != 1)' it fails
            const isCheckGone = !normCode.includes('if (is_valid != 1)');

            const isPatched = hasPayload && isCheckGone;

            if (isPatched) {
                heal(20);
                addStar(); // Star for second part
                setTerminalHistory(prev => [...prev, 
                    '> Executing updater.exe...',
                    '[SUCCESS] Signature Verified (Bypassed). Running update...',
                    '$ MISSION ACCOMPLISHED.'
                ]);
                setTimeout(() => {
                    setPhase(5);
                    winLevel();
                }, 1500);
                return null;
            } else {
                takeDamage(15);
                return [
                    '> Executing updater.exe...',
                    '[ERROR] Signature Verification Failed!',
                    '$ FAIL: The update service blocked the execution.'
                ];
            }
        }

        // UTILS
        if (cmd === 'ls') {
            return "auth.exe   updater.exe   README.txt";
        }
        
        return `Command not found: ${cmd}`;
    };

    // --- RENDER ---

    if (gameState !== 'playing') {
        const winRecap = `VULNERABILITÀ IDENTIFICATA: Logic Bypass & Client-Side Trust.
        
        Hai dimostrato come controlli di sicurezza implementati male lato client (es. IF nel codice locale) o verifiche di firme non robuste possono essere facilmente aggirati modificando il binario (.exe).
        
        LEZIONE APPRESA: Mai fidarsi dell'input lato client o di controlli che l'utente può manipolare. La validazione critica deve avvenire lato server o tramite firma digitale robusta non bypassabile.`;

        const lossRecap = `MISSIONE FALLITA. Sistema compromesso o troppi errori commessi.
        
        Non sei riuscito a bypassare le protezioni in modo sicuro o hai esaurito la salute del sistema.
        
        SUGGERIMENTO: Leggi attentamente i commenti nel codice C decompilato. Usa gli hint automatici che appaiono e ricorda che il tuo obiettivo è RENDERE VERA la condizione che blocca l'accesso, non necessariamente soddisfarla legittimamente.`;

        return (
            <MissionDebrief 
                success={gameState === 'won'}
                stats={{ stars, health }}
                recapText={gameState === 'won' ? winRecap : lossRecap}
                onRetry={() => window.location.reload()}
                onExit={() => navigate('/map')}
            />
        );
    }

    return (
        <LevelTemplateContent 
            title="Level 7: Reverse Engineering & Patching"
            subtitle="Analyze binary logic and bypass security controls"
            health={health}
            stars={stars}
            hint={visibleHint ? <InfoPanel text={visibleHint} /> : null}
            siemConfig={{
                logs: logs,
                blockedIPs: 1,
                currentStep: phase,
                onLogClick: handleLogClick
            }}
            terminalConfig={{
                initialHistory: terminalHistory,
                commands: {
                    'build': (args) => runTerminalCommand(args, 'build'),
                    'gcc': (args) => runTerminalCommand(args, 'gcc'),
                    './auth.exe': (args) => runTerminalCommand(args, './auth.exe'), 
                    './updater.exe': (args) => runTerminalCommand(args, './updater.exe'),
                    'ls': (args) => runTerminalCommand(args, 'ls'),
                    'help': () => "Available: ls, build, ./auth.exe, ./updater.exe"
                }
            }}
            revEngConfig={{
                files: files,
                onSave: handleCodeSave
            }}
        />
    );
};

const Level7 = () => (
    <LevelProvider initialHealth={100}>
        <Level7Content />
    </LevelProvider>
);

export default Level7;
